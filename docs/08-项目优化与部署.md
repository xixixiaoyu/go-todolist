# ğŸ“š Go Todolist é¡¹ç›®å­¦ä¹ æ–‡æ¡£ - ç¬¬å…«ç« ï¼šé¡¹ç›®ä¼˜åŒ–ä¸éƒ¨ç½²

## ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œæ‚¨å°†æŒæ¡ï¼š
- ä»£ç è´¨é‡ä¼˜åŒ–å’Œæ€§èƒ½æå‡
- å®‰å…¨æ€§åŠ å›ºå’Œæœ€ä½³å®è·µ
- æ„å»ºå’Œéƒ¨ç½²æµç¨‹è®¾è®¡
- ç›‘æ§å’Œæ—¥å¿—ç³»ç»Ÿé…ç½®
- ç”Ÿäº§ç¯å¢ƒè¿ç»´æŠ€å·§

## ğŸ“‹ ä¼˜åŒ–æ¦‚è¿°

é¡¹ç›®ä¼˜åŒ–æ˜¯å°†å¼€å‘ç‰ˆæœ¬è½¬æ¢ä¸ºç”Ÿäº§å°±ç»ªç‰ˆæœ¬çš„å…³é”®æ­¥éª¤ï¼ŒåŒ…æ‹¬ï¼š

1. **æ€§èƒ½ä¼˜åŒ–**ï¼šæå‡åº”ç”¨å“åº”é€Ÿåº¦å’Œèµ„æºåˆ©ç”¨ç‡
2. **å®‰å…¨åŠ å›º**ï¼šé˜²èŒƒå¸¸è§çš„å®‰å…¨å¨èƒ
3. **ä»£ç è´¨é‡**ï¼šæé«˜ä»£ç çš„å¯ç»´æŠ¤æ€§å’Œå¯è¯»æ€§
4. **éƒ¨ç½²å‡†å¤‡**ï¼šé…ç½®ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²æµç¨‹
5. **ç›‘æ§å‘Šè­¦**ï¼šå»ºç«‹å®Œå–„çš„ç›‘æ§ä½“ç³»

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### 1. åç«¯æ€§èƒ½ä¼˜åŒ–

#### HTTP æœåŠ¡å™¨é…ç½®ä¼˜åŒ–

```go
// ä¼˜åŒ–çš„æœåŠ¡å™¨é…ç½®
func createOptimizedServer(handler http.Handler, port string) *http.Server {
    return &http.Server{
        Addr:         ":" + port,
        Handler:      handler,
        ReadTimeout:  15 * time.Second,  // è¯»å–è¶…æ—¶
        WriteTimeout: 15 * time.Second,  // å†™å…¥è¶…æ—¶
        IdleTimeout:  60 * time.Second,  // ç©ºé—²è¿æ¥è¶…æ—¶
        MaxHeaderBytes: 1 << 20,         // æœ€å¤§è¯·æ±‚å¤´å¤§å° 1MB
    }
}
```

#### å†…å­˜å­˜å‚¨ä¼˜åŒ–

```go
// ä¼˜åŒ–çš„å†…å­˜å­˜å‚¨å®ç°
type OptimizedMemoryStorage struct {
    todos    map[int]*models.Todo
    todoList []*models.Todo  // æ·»åŠ åˆ‡ç‰‡ç¼“å­˜ï¼Œä¼˜åŒ– GetAll æ“ä½œ
    nextID   int
    mutex    sync.RWMutex
    dirty    bool            // æ ‡è®°æ•°æ®æ˜¯å¦å·²ä¿®æ”¹
}

// ä¼˜åŒ–çš„ GetAll æ–¹æ³•
func (s *OptimizedMemoryStorage) GetAll() ([]*models.Todo, error) {
    s.mutex.RLock()
    defer s.mutex.RUnlock()
    
    // å¦‚æœæ•°æ®æœªä¿®æ”¹ï¼Œç›´æ¥è¿”å›ç¼“å­˜
    if !s.dirty && s.todoList != nil {
        return s.todoList, nil
    }
    
    // é‡å»ºç¼“å­˜
    s.mutex.RUnlock()
    s.mutex.Lock()
    defer s.mutex.Unlock()
    defer s.mutex.RLock()
    
    s.todoList = make([]*models.Todo, 0, len(s.todos))
    for _, todo := range s.todos {
        s.todoList = append(s.todoList, todo)
    }
    s.dirty = false
    
    return s.todoList, nil
}
```

#### å“åº”å‹ç¼©ä¸­é—´ä»¶

```go
// Gzip å‹ç¼©ä¸­é—´ä»¶
func gzipMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        if !strings.Contains(r.Header.Get("Accept-Encoding"), "gzip") {
            next.ServeHTTP(w, r)
            return
        }
        
        w.Header().Set("Content-Encoding", "gzip")
        w.Header().Set("Content-Type", "application/json")
        
        gz := gzip.NewWriter(w)
        defer gz.Close()
        
        gzw := &gzipResponseWriter{Writer: gz, ResponseWriter: w}
        next.ServeHTTP(gzw, r)
    })
}

type gzipResponseWriter struct {
    io.Writer
    http.ResponseWriter
}

func (w *gzipResponseWriter) Write(b []byte) (int, error) {
    return w.Writer.Write(b)
}
```

### 2. å‰ç«¯æ€§èƒ½ä¼˜åŒ–

#### èµ„æºä¼˜åŒ–

```html
<!-- ä¼˜åŒ–çš„ HTML å¤´éƒ¨ -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¾…åŠäº‹é¡¹ç®¡ç†</title>
    
    <!-- é¢„åŠ è½½å…³é”®èµ„æº -->
    <link rel="preload" href="style.css" as="style">
    <link rel="preload" href="script.js" as="script">
    
    <!-- æ ·å¼è¡¨ -->
    <link rel="stylesheet" href="style.css">
    
    <!-- æ€§èƒ½ä¼˜åŒ– meta æ ‡ç­¾ -->
    <meta name="theme-color" content="#667eea">
    <meta name="description" content="ç®€å•é«˜æ•ˆçš„å¾…åŠäº‹é¡¹ç®¡ç†å·¥å…·">
</head>
```

#### JavaScript æ€§èƒ½ä¼˜åŒ–

```javascript
// é˜²æŠ–å‡½æ•°ï¼Œä¼˜åŒ–æœç´¢å’Œè¾“å…¥
function debounce(func, wait) {
  let timeout
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout)
      func(...args)
    }
    clearTimeout(timeout)
    timeout = setTimeout(later, wait)
  }
}

// ä¼˜åŒ–çš„æœç´¢åŠŸèƒ½
const debouncedSearch = debounce((query) => {
  filterTodos(query)
}, 300)

// è™šæ‹Ÿæ»šåŠ¨ï¼ˆå¤§é‡æ•°æ®æ—¶ï¼‰
class VirtualList {
  constructor(container, itemHeight, renderItem) {
    this.container = container
    this.itemHeight = itemHeight
    this.renderItem = renderItem
    this.visibleStart = 0
    this.visibleEnd = 0
    
    this.setupScrollListener()
  }
  
  render(items) {
    const containerHeight = this.container.clientHeight
    const visibleCount = Math.ceil(containerHeight / this.itemHeight)
    
    this.visibleStart = Math.floor(this.container.scrollTop / this.itemHeight)
    this.visibleEnd = Math.min(this.visibleStart + visibleCount, items.length)
    
    const visibleItems = items.slice(this.visibleStart, this.visibleEnd)
    
    this.container.innerHTML = visibleItems
      .map((item, index) => this.renderItem(item, this.visibleStart + index))
      .join('')
  }
}
```

## ğŸ”’ å®‰å…¨æ€§åŠ å›º

### 1. è¾“å…¥éªŒè¯å’Œæ¸…ç†

```go
// æœåŠ¡å™¨ç«¯è¾“å…¥éªŒè¯å¢å¼º
func (req *CreateTodoRequest) ValidateAndSanitize() error {
    // æ¸…ç†è¾“å…¥
    req.Title = strings.TrimSpace(req.Title)
    req.Description = strings.TrimSpace(req.Description)
    
    // éªŒè¯é•¿åº¦
    if len(req.Title) == 0 {
        return &ValidationError{Field: "title", Message: "æ ‡é¢˜ä¸èƒ½ä¸ºç©º"}
    }
    if len(req.Title) > 100 {
        return &ValidationError{Field: "title", Message: "æ ‡é¢˜é•¿åº¦ä¸èƒ½è¶…è¿‡100ä¸ªå­—ç¬¦"}
    }
    if len(req.Description) > 500 {
        return &ValidationError{Field: "description", Message: "æè¿°é•¿åº¦ä¸èƒ½è¶…è¿‡500ä¸ªå­—ç¬¦"}
    }
    
    // æ£€æŸ¥æ¶æ„å†…å®¹
    if containsMaliciousContent(req.Title) || containsMaliciousContent(req.Description) {
        return &ValidationError{Field: "content", Message: "è¾“å…¥åŒ…å«ä¸å…è®¸çš„å†…å®¹"}
    }
    
    return nil
}

// æ£€æŸ¥æ¶æ„å†…å®¹
func containsMaliciousContent(content string) bool {
    maliciousPatterns := []string{
        "<script",
        "javascript:",
        "onload=",
        "onerror=",
        "eval(",
    }
    
    lowerContent := strings.ToLower(content)
    for _, pattern := range maliciousPatterns {
        if strings.Contains(lowerContent, pattern) {
            return true
        }
    }
    return false
}
```

### 2. CORS å®‰å…¨é…ç½®

```go
// å®‰å…¨çš„ CORS é…ç½®
func (h *TodoHandler) setCORSHeaders(w http.ResponseWriter) {
    // ç”Ÿäº§ç¯å¢ƒåº”è¯¥æŒ‡å®šå…·ä½“çš„åŸŸå
    origin := os.Getenv("ALLOWED_ORIGIN")
    if origin == "" {
        origin = "*" // ä»…å¼€å‘ç¯å¢ƒä½¿ç”¨
    }
    
    w.Header().Set("Access-Control-Allow-Origin", origin)
    w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
    w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
    w.Header().Set("Access-Control-Max-Age", "86400") // 24å°æ—¶
}
```

### 3. å‰ç«¯å®‰å…¨æªæ–½

```javascript
// XSS é˜²æŠ¤ - HTML è½¬ä¹‰
function escapeHtml(text) {
  const div = document.createElement('div')
  div.textContent = text
  return div.innerHTML
}

// å®‰å…¨çš„ DOM æ›´æ–°
function safeUpdateHTML(element, content) {
  // ä½¿ç”¨ textContent è€Œä¸æ˜¯ innerHTML
  element.textContent = content
}

// è¾“å…¥éªŒè¯
function validateInput(input) {
  // ç§»é™¤æ½œåœ¨çš„æ¶æ„å­—ç¬¦
  return input
    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
    .replace(/javascript:/gi, '')
    .replace(/on\w+\s*=/gi, '')
}
```

## ğŸ“¦ æ„å»ºå’Œéƒ¨ç½²

### 1. Docker å®¹å™¨åŒ–

```dockerfile
# Dockerfile
FROM golang:1.21-alpine AS builder

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /app

# å¤åˆ¶ go mod æ–‡ä»¶
COPY go.mod go.sum ./

# ä¸‹è½½ä¾èµ–
RUN go mod download

# å¤åˆ¶æºä»£ç 
COPY . .

# æ„å»ºåº”ç”¨
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

# ä½¿ç”¨è½»é‡çº§é•œåƒ
FROM alpine:latest

# å®‰è£… ca-certificates
RUN apk --no-cache add ca-certificates

WORKDIR /root/

# ä»æ„å»ºé˜¶æ®µå¤åˆ¶äºŒè¿›åˆ¶æ–‡ä»¶
COPY --from=builder /app/main .
COPY --from=builder /app/static ./static

# æš´éœ²ç«¯å£
EXPOSE 8080

# è¿è¡Œåº”ç”¨
CMD ["./main"]
```

### 2. Docker Compose é…ç½®

```yaml
# docker-compose.yml
version: '3.8'

services:
  todolist:
    build: .
    ports:
      - "8080:8080"
    environment:
      - PORT=8080
      - ALLOWED_ORIGIN=http://localhost:8080
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:8080/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # å¯é€‰ï¼šæ·»åŠ åå‘ä»£ç†
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - todolist
    restart: unless-stopped
```

### 3. Nginx åå‘ä»£ç†é…ç½®

```nginx
# nginx.conf
events {
    worker_connections 1024;
}

http {
    upstream todolist {
        server todolist:8080;
    }

    # HTTP é‡å®šå‘åˆ° HTTPS
    server {
        listen 80;
        server_name your-domain.com;
        return 301 https://$server_name$request_uri;
    }

    # HTTPS é…ç½®
    server {
        listen 443 ssl http2;
        server_name your-domain.com;

        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;

        # å®‰å…¨å¤´
        add_header X-Frame-Options DENY;
        add_header X-Content-Type-Options nosniff;
        add_header X-XSS-Protection "1; mode=block";
        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains";

        # é™æ€æ–‡ä»¶ç¼“å­˜
        location ~* \.(css|js|png|jpg|jpeg|gif|ico|svg)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }

        # API ä»£ç†
        location /api/ {
            proxy_pass http://todolist;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # å‰ç«¯æ–‡ä»¶
        location / {
            proxy_pass http://todolist;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}
```

## ğŸ“Š ç›‘æ§å’Œæ—¥å¿—

### 1. ç»“æ„åŒ–æ—¥å¿—

```go
// æ—¥å¿—ä¸­é—´ä»¶
func loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // åŒ…è£… ResponseWriter ä»¥æ•è·çŠ¶æ€ç 
        wrapped := &responseWriter{ResponseWriter: w, statusCode: 200}
        
        next.ServeHTTP(wrapped, r)
        
        // è®°å½•è¯·æ±‚æ—¥å¿—
        log.Printf(
            "method=%s path=%s status=%d duration=%v ip=%s user_agent=%s",
            r.Method,
            r.URL.Path,
            wrapped.statusCode,
            time.Since(start),
            getClientIP(r),
            r.UserAgent(),
        )
    })
}

type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}

func getClientIP(r *http.Request) string {
    // æ£€æŸ¥ X-Forwarded-For å¤´
    if xff := r.Header.Get("X-Forwarded-For"); xff != "" {
        return strings.Split(xff, ",")[0]
    }
    
    // æ£€æŸ¥ X-Real-IP å¤´
    if xri := r.Header.Get("X-Real-IP"); xri != "" {
        return xri
    }
    
    // ä½¿ç”¨ RemoteAddr
    ip, _, _ := net.SplitHostPort(r.RemoteAddr)
    return ip
}
```

### 2. å¥åº·æ£€æŸ¥ç«¯ç‚¹

```go
// å¥åº·æ£€æŸ¥å¤„ç†å™¨
func healthCheckHandler(storage storage.TodoStorage) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // æ£€æŸ¥å­˜å‚¨å±‚å¥åº·çŠ¶æ€
        _, err := storage.GetAll()
        if err != nil {
            w.WriteHeader(http.StatusServiceUnavailable)
            json.NewEncoder(w).Encode(map[string]string{
                "status": "unhealthy",
                "error":  err.Error(),
            })
            return
        }
        
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
            "status":    "healthy",
            "timestamp": time.Now().Unix(),
            "version":   "1.0.0",
        })
    }
}

// åœ¨ main.go ä¸­æ·»åŠ å¥åº·æ£€æŸ¥è·¯ç”±
mux.HandleFunc("/health", healthCheckHandler(todoStorage))
```

### 3. æŒ‡æ ‡æ”¶é›†

```go
// ç®€å•çš„æŒ‡æ ‡æ”¶é›†
type Metrics struct {
    RequestCount    int64
    ErrorCount      int64
    ResponseTimeSum time.Duration
    mutex           sync.RWMutex
}

func (m *Metrics) RecordRequest(duration time.Duration, isError bool) {
    m.mutex.Lock()
    defer m.mutex.Unlock()
    
    m.RequestCount++
    m.ResponseTimeSum += duration
    
    if isError {
        m.ErrorCount++
    }
}

func (m *Metrics) GetStats() map[string]interface{} {
    m.mutex.RLock()
    defer m.mutex.RUnlock()
    
    avgResponseTime := time.Duration(0)
    if m.RequestCount > 0 {
        avgResponseTime = m.ResponseTimeSum / time.Duration(m.RequestCount)
    }
    
    return map[string]interface{}{
        "request_count":       m.RequestCount,
        "error_count":         m.ErrorCount,
        "avg_response_time":   avgResponseTime.String(),
        "error_rate":          float64(m.ErrorCount) / float64(m.RequestCount),
    }
}

// æŒ‡æ ‡ç«¯ç‚¹
func metricsHandler(metrics *Metrics) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(metrics.GetStats())
    }
}
```

## ğŸš€ éƒ¨ç½²è„šæœ¬

### 1. è‡ªåŠ¨åŒ–éƒ¨ç½²è„šæœ¬

```bash
#!/bin/bash
# deploy.sh

set -e

echo "ğŸš€ å¼€å§‹éƒ¨ç½² Go Todolist åº”ç”¨..."

# æ£€æŸ¥ Docker æ˜¯å¦å®‰è£…
if ! command -v docker &> /dev/null; then
    echo "âŒ Docker æœªå®‰è£…ï¼Œè¯·å…ˆå®‰è£… Docker"
    exit 1
fi

# æ„å»º Docker é•œåƒ
echo "ğŸ“¦ æ„å»º Docker é•œåƒ..."
docker build -t go-todolist:latest .

# åœæ­¢ç°æœ‰å®¹å™¨
echo "â¹ï¸ åœæ­¢ç°æœ‰å®¹å™¨..."
docker stop go-todolist || true
docker rm go-todolist || true

# å¯åŠ¨æ–°å®¹å™¨
echo "ğŸ”„ å¯åŠ¨æ–°å®¹å™¨..."
docker run -d \
  --name go-todolist \
  --restart unless-stopped \
  -p 8080:8080 \
  -e PORT=8080 \
  go-todolist:latest

# ç­‰å¾…æœåŠ¡å¯åŠ¨
echo "â³ ç­‰å¾…æœåŠ¡å¯åŠ¨..."
sleep 5

# å¥åº·æ£€æŸ¥
if curl -f http://localhost:8080/health > /dev/null 2>&1; then
    echo "âœ… éƒ¨ç½²æˆåŠŸï¼åº”ç”¨å·²å¯åŠ¨"
    echo "ğŸŒ è®¿é—®åœ°å€: http://localhost:8080"
else
    echo "âŒ éƒ¨ç½²å¤±è´¥ï¼ŒæœåŠ¡æœªæ­£å¸¸å¯åŠ¨"
    docker logs go-todolist
    exit 1
fi
```

### 2. ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²

```bash
#!/bin/bash
# production-deploy.sh

# è®¾ç½®ç¯å¢ƒå˜é‡
export DOCKER_REGISTRY="your-registry.com"
export IMAGE_TAG="v$(date +%Y%m%d-%H%M%S)"
export APP_NAME="go-todolist"

# æ„å»ºå¹¶æ¨é€é•œåƒ
docker build -t $DOCKER_REGISTRY/$APP_NAME:$IMAGE_TAG .
docker push $DOCKER_REGISTRY/$APP_NAME:$IMAGE_TAG

# ä½¿ç”¨ Docker Compose éƒ¨ç½²
envsubst < docker-compose.prod.yml | docker-compose -f - up -d

echo "âœ… ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²å®Œæˆ"
echo "ğŸ·ï¸ é•œåƒæ ‡ç­¾: $IMAGE_TAG"
```

## ğŸ¯ æœ¬ç« å°ç»“

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œæˆ‘ä»¬å®Œæˆäº†ï¼š

1. âœ… **æ€§èƒ½ä¼˜åŒ–**ï¼šæœåŠ¡å™¨é…ç½®ã€ç¼“å­˜ç­–ç•¥ã€èµ„æºä¼˜åŒ–
2. âœ… **å®‰å…¨åŠ å›º**ï¼šè¾“å…¥éªŒè¯ã€CORS é…ç½®ã€XSS é˜²æŠ¤
3. âœ… **å®¹å™¨åŒ–éƒ¨ç½²**ï¼šDocker é…ç½®ã€åå‘ä»£ç†è®¾ç½®
4. âœ… **ç›‘æ§ç³»ç»Ÿ**ï¼šæ—¥å¿—è®°å½•ã€å¥åº·æ£€æŸ¥ã€æŒ‡æ ‡æ”¶é›†
5. âœ… **è‡ªåŠ¨åŒ–éƒ¨ç½²**ï¼šéƒ¨ç½²è„šæœ¬ã€ç”Ÿäº§ç¯å¢ƒé…ç½®

### å…³é”®æ”¶è·
- æŒæ¡äº† Go åº”ç”¨çš„æ€§èƒ½ä¼˜åŒ–æŠ€å·§
- ç†è§£äº† Web åº”ç”¨çš„å®‰å…¨æœ€ä½³å®è·µ
- å­¦ä¼šäº†å®¹å™¨åŒ–éƒ¨ç½²çš„å®Œæ•´æµç¨‹
- å®ç°äº†ç”Ÿäº§çº§åˆ«çš„ç›‘æ§å’Œæ—¥å¿—ç³»ç»Ÿ

### é¡¹ç›®æ€»ç»“
ç»è¿‡å…«ä¸ªç« èŠ‚çš„å­¦ä¹ ï¼Œæˆ‘ä»¬ä»é›¶å¼€å§‹æ„å»ºäº†ä¸€ä¸ªå®Œæ•´çš„ Go Todolist åº”ç”¨ï¼Œæ¶µç›–äº†ï¼š
- åç«¯ API å¼€å‘
- å‰ç«¯ç•Œé¢è®¾è®¡
- æ•°æ®å­˜å‚¨ç®¡ç†
- å®‰å…¨æ€§è€ƒè™‘
- éƒ¨ç½²å’Œè¿ç»´

è¿™ä¸ªé¡¹ç›®å±•ç¤ºäº†ç°ä»£ Web åº”ç”¨å¼€å‘çš„å®Œæ•´æµç¨‹å’Œæœ€ä½³å®è·µã€‚

---

**ä¼˜åŒ–å’Œéƒ¨ç½²æ˜¯é¡¹ç›®çš„æœ€åä¸€å…¬é‡Œï¼Œå†³å®šäº†åº”ç”¨åœ¨ç”Ÿäº§ç¯å¢ƒä¸­çš„è¡¨ç°ï¼** ğŸš€
